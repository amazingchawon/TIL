# 힙 Heap

1. 정의 : **완전 이진 트리**에 있는 노드 중에서 키 값이 가장 큰 노드나, 키 값이 가장 작은 노드를 찾기 위해 만든 자료구조
2. 최대 힙 max Heap :
    - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - 규칙 : 부모 노드의 키 값 > 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 큰 노드
3. 최소 힙 min Heap:
    - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - 규칙 : 부모 노드의 키 값 < 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 작은 노드

## 힙 연산 - 삽입

1. 방법 :
    - 일단 맨 뒤에 삽입
    - 내 위치를 찾아감
2. 시간 복잡도 : O(logN)
    - 만약 N개의 데이터를 힙으로 만든다 → O(NlogN)

## 힙 연산 - 삭제

1. 특징
    - 루트 노드의 원소만 삭제 가능
    - 루트 노드의 원소 삭제 → 반환
    - 힙의 종류에 따라 최대값 or 최소값을 구할 수 있음
    - 힙의 키를 우선 순위로 활용하여 우선순위 큐 구현 가능
        - 우선 순위가 높은 데이터부터 확인 가능
2. 방법 :
    - 루트 원소 삭제 시
        - 루트 원소 자리에 마지막 노드로 변경
        - 마지막 노드 삭제
        - 자리 바꾸기
3. 시간 복잡도 : O(logN)

## 구현 (최대힙)

```python
'''
7
20 15 19 4 13 11 17

7
20 15 19 4 13 11 23
'''

# 최대힙
def enq(n):
    global last
    last += 1   # 마지막 노드 추가(완전이진트리 유지)
    h[last] = n # 마지막 노드에 데이터 삽입
    c = last    # 부모>자식 비교를 위해
    p = c//2    # 부모번호 계산
    while p >= 1 and h[p] < h[c]:   # 부모가 있는데, 더 작으면
        h[p], h[c] = h[c], h[p]  # 교환
        c = p
        p = c//2

def deq():
    global last
    tmp = h[1]   # 루트의 키값 보관
    h[1] = h[last]
    last -= 1
    p = 1           # 새로 옮긴 루트
    c = p*2
    while c <= last:  # 자식이 있으면
        if c+1 <= last and h[c] < h[c+1]: # 오른쪽자식이 있고 더 크면
            c += 1
        if h[p] < h[c]:
            h[p], h[c] = h[c], h[p]
            p = c
            c = p*2
        else:
            break
    return tmp

N = int(input())          # 필요한 노드 수
arr = list(map(int, input().split()))

h = [0]*(N+1)   # 최대힙
last = 0        # 힙의 마지막 노드 번호

for num in arr:
    enq(num)

print(h)

while last > 0:
    print(deq(), end=' ')

```

## BST VS Heap

1. 공통점
    - 트리 기반 자료구조
2. 차이점
    - 구조적 특성
        
        
        | BST | Heap |
        | --- | --- |
        | 완전이진트리 보장 X | 완전 이진 트리 형태 유지 |
        | 모든 노드에 대해 왼쪽 서브트리의 값 < 노드의 값 < 오른쪽 서브트리의 값 | 부모 노드와 자식 노드간의 대소관계만 정의 |
        | 중위 순회 시 정렬된 순서로 노드 방문 | 형제 노드 간 순서는 정의되지 않음 |
        | 불균형해질 수 있음 | 항상 균형 유지 |
3. 주요 용도
    - BST
        - 효율적인 검색, 삽입, 삭제 연산이 필요한 경우
        - 정렬된 데이터 유지
        - 범위 쿼리 수행
    - Heap
        - 우선순위 큐 구현
        - 힙 정렬
        - 최대값 또는 최소값을 빠르게 찾아야 하는 경우