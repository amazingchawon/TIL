# DP

## Memoization

+. 피보나치 수열을 재귀로 구현했을 때 문제 : 엄청난 중복 호출이 존재

1. 정의 : 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술, 동적 계획법(DP)의 핵심 기술
2. Memoization을 사용한 피보나치 수열
    
    ```python
    # memo를 위한 배열을 할당하고, 모두 0으로 초기화
    # memo[0]을 0으로 memo[1]은 1로 초기화
    
    def fibo_memo(n):
    	global memo # 이 라인 없어도 동작 가능 (arr이기 때문에 밖에 있어도 참조 가능)
    		if n >= 2 and memo[n] == 0: # n이 2보다 크고, fibo_memo[n]을 이전에 계산하지 않았다면(= memo[n] ==0)
    			memo[n] = fibo_memo(n-1) + fibo_memo(n-2)
    		return memo[n] # 이미 계산한 적 있으면 그 값 반환
    		
    memo = [0] * (n+1)
    memo[0] = 1
    memo[1] = 1
    ```
    

## DP (Dynamic Programming)

1. 정의 :
    - 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
    - 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결 → 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘
2. DP를 적용한 피보나치 수열
    
    ```python
    def fibo_dp(n):
    	f = [0] * (n+1)
    	f[0] = 0
    	f[1] = 1
    	for i in range(2, n+1):
    		f[i] = f[i-1] + f[i-2]
    	
    	return f[n]
    ```


## 메모이제이션과 DP의 관계

### 1. 메모이제이션 (Memoization)

- 정의: 이전에 계산한 결과를 저장하고 재사용하는 최적화 기법
- 특징:
  - 주로 재귀 함수에서 사용됨
  - Top-down 방식으로 구현 (큰 문제에서 작은 문제로)
  - 필요한 부분만 계산 (Lazy Evaluation)
- 장점: 
  - 구현이 직관적이고 간단함
  - 필요한 부분만 계산하므로 불필요한 계산 회피 가능
- 단점:
  - 재귀 호출로 인한 오버헤드 발생 가능
  - 스택 오버플로우 위험

### 2. 동적 계획법 (Dynamic Programming, DP)

- 정의: 복잡한 문제를 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법
- 특징:
  - 반복문을 사용하여 구현하는 경우가 많음
  - Bottom-up 방식으로 구현 (작은 문제에서 큰 문제로)
  - 모든 부분 문제를 한 번씩 계산
- 장점
  - 반복문 사용으로 재귀 호출 오버헤드 없음
  - 모든 부분 문제를 순차적으로 해결하여 안정적
- 단점
  - 때로는 불필요한 부분까지 계산할 수 있음
  - 구현이 메모이제이션보다 복잡할 수 있음

### 3. 관계

- 메모이제이션은 DP를 구현하는 한 가지 방법
- DP는 메모이제이션을 포함하는 더 넓은 개념
- 둘 다 중복 계산을 피하고 효율성을 높이는 것이 목표



### 4. 예시: 피보나치 수열

메모이제이션 (Top-down):

```python
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

DP (Bottom-up):

```python
def fib(n):
    if n <= 1:
        return n
    dp = [0] * (n+1)
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

두 방법 모두 중복 계산을 피하고 효율성을 높이는 데 사용되지만, 접근 방식과 구현 방법에서 차이가 있습니다.