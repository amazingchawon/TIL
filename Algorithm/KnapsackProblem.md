# 배낭 문제(Knapsack Problem)

## 배낭 문제란?
- 제한된 자원(무게, 시간 등) 안에서 **최대 이익을 얻는 방법**을 찾는 문제  
- **동적 계획법(DP)**을 활용하여 최적의 해를 구함  
- 대표적인 **조합 최적화 문제**  

---

## 배낭 문제 유형

| 유형 | 선택 가능 여부 | 알고리즘 | 시간 복잡도 |
|------|--------------|---------|------------|
| **0-1 배낭 문제** | ❌ (각 아이템 1번만 선택 가능) | DP | `O(NW)` |
| **부분 배낭 문제** | ✅ (일부 선택 가능) | Greedy (비율 정렬) | `O(N log N)` |
| **무제한 배낭 문제** | ✅ (같은 아이템 여러 번 선택 가능) | DP | `O(NW)` |

---

## 0-1 배낭 문제 (0/1 Knapsack Problem)
### **🔹 문제 설명**
- `N`개의 물건이 있고, 각각 **(무게, 가치)** 가 주어짐  
- 배낭의 최대 허용 무게는 `W`  
- **각 물건을 1번만 선택 가능**  
- **최대 가치를 얻을 수 있도록 물건을 선택**해야 함  

### 점화식 (DP State Transition)
- `DP[i][w]`: **i번째 아이템까지 고려했을 때, 무게 w 이하에서 얻을 수 있는 최대 가치**  
- **현재 아이템을 선택하지 않는 경우**  
  ```DP[i][w] = DP[i-1][w]```  
- **현재 아이템을 선택하는 경우** (현재 무게를 감당 가능할 때)  
  ```DP[i][w] = max(DP[i-1][w], DP[i-1][w - weight] + value)```  
- 두 경우 중 **더 큰 값을 선택**하여 최적해를 구함  

---

## 0-1 배낭 문제 코드
```python
# 입력: 아이템 개수 N, 최대 무게 W
N, W = map(int, input().split())

# 아이템 정보 저장 (무게, 가치)
items = [list(map(int, input().split())) for _ in range(N)]

# DP 테이블 초기화
DP = [[0] * (W + 1) for _ in range(N + 1)]

# DP 진행 (Bottom-Up)
for i in range(1, N + 1):
    weight, value = items[i - 1]
    for w in range(1, W + 1):
        if w < weight:
            DP[i][w] = DP[i-1][w]  # 현재 아이템을 담을 수 없는 경우
        else:
            DP[i][w] = max(DP[i-1][w], DP[i-1][w-weight] + value)

# 결과 출력: 최대 가치
print(DP[N][W])
```
## 7️⃣ **핵심 정리**
✅ **배낭 문제 유형의 DP 풀이 적용**  
✅ **`DP[i][w] = max(선택하지 않음, 선택함 + 아이템 가치)`**  
✅ **시간 복잡도 `O(NW)`, 공간 최적화 시 `O(W)`**  
✅ **다양한 문제에 응용 가능 (도서 읽기, 동전 거스름돈, 여행 계획 등)**  

💡 **배낭 문제를 잘 이해하면 비슷한 문제도 쉽게 풀 수 있음!** 🚀
